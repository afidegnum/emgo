// Package smodels contains the types for schema 'sweb'.
package smodels

// Code generated by xo. DO NOT EDIT.

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"log"
	"net/http"
	"strconv"

	"github.com/go-chi/chi"
	"github.com/google/jsonapi"
	"github.com/lib/pq"
	"github.com/thedevsaddam/renderer"
	"github.com/xo/dburl"
)

var rnd = renderer.New()

//var FlagVerbose = flag.Bool("v", true, "verbose")

var FlagURL = flag.String("url", "postgres://postgres:@127.0.0.1/sweb", "url") // Page represents a row from 'sweb.pages'.

//TODO manually adjust fields settings based on jsonapi module. -Alx
type Page struct {
	ID           int            `jsonapi:"attr.id"json:"id"`                       // id
	Title        sql.NullString `jsonapi:"attr.title"json:"title"`                 // title
	Slug         sql.NullString `jsonapi:"attr.slug"json:"slug"`                   // slug
	Body         sql.NullString `jsonapi:"attr.body"json:"body"`                   // body
	Intro        sql.NullString `jsonapi:"attr.intro"json:"intro"`                 // intro
	CreatedDate  pq.NullTime    `jsonapi:"attr.created_date"json:"created_date"`   // created_date
	ModifiedDate pq.NullTime    `jsonapi:"attr.modified_date"json:"modified_date"` // modified_date

	// xo fields
	_exists, _deleted bool
}

func panicError(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func (page Page) JSONAPILinks() *jsonapi.Links {
	return &jsonapi.Links{
		//TOOD Verify if primary key ID
		"self": fmt.Sprintf("https://%d", page.ID),
	}
}

// Exists determines if the Page exists in the database.
func (p *Page) Exists() bool {
	return p._exists
}

// Deleted provides information if the Page has been deleted from the database.
func (p *Page) Deleted() bool {
	return p._deleted
}

// Insert inserts the Page to the database.
func (p *Page) Insert(db XODB) (*Page, error) {
	var err error

	// if already exist, bail
	if p._exists {
		return p, errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO sweb.pages (` +
		`title, slug, body, intro, created_date, modified_date` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) RETURNING id`

	// run query
	XOLog(sqlstr, p.Title, p.Slug, p.Body, p.Intro, p.CreatedDate, p.ModifiedDate)
	err = db.QueryRow(sqlstr, p.Title, p.Slug, p.Body, p.Intro, p.CreatedDate, p.ModifiedDate).Scan(&p.ID)
	if err != nil {
		return p, err
	}

	// set existence
	p._exists = true

	return p, nil
}

// Update updates the Page in the database.
func (p *Page) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !p._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if p._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE sweb.pages SET (` +
		`title, slug, body, intro, created_date, modified_date` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6` +
		`) WHERE id = $7`

	// run query
	XOLog(sqlstr, p.Title, p.Slug, p.Body, p.Intro, p.CreatedDate, p.ModifiedDate, p.ID)
	_, err = db.Exec(sqlstr, p.Title, p.Slug, p.Body, p.Intro, p.CreatedDate, p.ModifiedDate, p.ID)
	return err
}

// Save saves the Page to the database.
func (p *Page) Save(db XODB) (*Page, error) {
	if p.Exists() {
		return p, p.Update(db)
	}

	return p.Insert(db)
}

// Upsert performs an upsert for Page.
//
// NOTE: PostgreSQL 9.5+ only
func (p *Page) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if p._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO sweb.pages (` +
		`id, title, slug, body, intro, created_date, modified_date` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) ON CONFLICT (id) DO UPDATE SET (` +
		`id, title, slug, body, intro, created_date, modified_date` +
		`) = (` +
		`EXCLUDED.id, EXCLUDED.title, EXCLUDED.slug, EXCLUDED.body, EXCLUDED.intro, EXCLUDED.created_date, EXCLUDED.modified_date` +
		`)`

	// run query
	XOLog(sqlstr, p.ID, p.Title, p.Slug, p.Body, p.Intro, p.CreatedDate, p.ModifiedDate)
	_, err = db.Exec(sqlstr, p.ID, p.Title, p.Slug, p.Body, p.Intro, p.CreatedDate, p.ModifiedDate)
	if err != nil {
		return err
	}

	// set existence
	p._exists = true

	return nil
}

// Delete deletes the Page from the database.
func (p *Page) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !p._exists {
		return nil
	}

	// if deleted, bail
	if p._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM sweb.pages WHERE id = $1`

	// run query
	XOLog(sqlstr, p.ID)
	_, err = db.Exec(sqlstr, p.ID)
	if err != nil {
		return err
	}

	// set deleted
	p._deleted = true

	return nil
}

// Personal Add
// FetchAllPage returns all from 'sweb.pages',


//TODO: Code Generator need to add pointer reference & to scan .... Comma is appended at 'FROM'
func FetchAllPage(db XODB) ([]*Page, error) {
	const sqlstr = `SELECT ` +
		`id, title, slug, body, intro, created_date, modified_date FROM sweb.pages`

	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Page
	for q.Next() {
		p := Page{}

		// scan
		err = q.Scan(&p.ID, &p.Title, &p.Slug, &p.Body, &p.Intro, &p.CreatedDate, &p.ModifiedDate)
		if err != nil {
			return nil, err
		}

		res = append(res, &p)

	}

	return res, nil
}

// ROUTE HANDLERS

func PageHandler(w http.ResponseWriter, r *http.Request) {

	//DB OPERATIONS START

	//flag.Parse()
	//if *FlagVerbose {
	//	XOLog = func(s string, p ...interface{}) {
	//		fmt.Printf("-------------------------------------\nQUERY: %s\n  VAL: %v\n", s, p)
	//	}
	//}

	// open database
	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	res, err := FetchAllPage(db)

	if err != nil {
		log.Fatal(err)
	}
	w.Header().Set("Content-Type", jsonapi.MediaType)

	if err := jsonapi.MarshalPayload(w, res); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}

}

func NewPage(w http.ResponseWriter, r *http.Request) {

	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	defer db.Close()

	var page Page

	if err := jsonapi.UnmarshalPayload(r.Body, &page); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	//page := new(Page)
	// 1. Save the page in the database, bail on error

	p, err := page.Save(db)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// 2. Marshal the page into an intermediate buffer, bail on error

	var buf bytes.Buffer
	if err := jsonapi.MarshalPayload(&buf, p); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// 3. Write the entire response; failures to write the intermediate buffer
	// cannot be communicated over HTTP
	w.Header().Set("Content-Type", jsonapi.MediaType)
	w.WriteHeader(http.StatusCreated)
	if _, err := buf.WriteTo(w); err != nil {
		log.Printf("failed to write response: %v", err)
		return
	}

}

func GetPage(w http.ResponseWriter, r *http.Request) {

	//DB OPERATIONS START

	//flag.Parse()
	//if *FlagVerbose {
	//	XOLog = func(s string, p ...interface{}) {
	//		fmt.Printf("-------------------------------------\nQUERY: %s\n  VAL: %v\n", s, p)
	//	}
	//}

	// open database
	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	res, err := FetchAllPage(db)

	if err != nil {
		log.Fatal(err)
	}

	rnd.JSON(w, http.StatusOK, res)

}

//ROUTE HANDLERS

func PageCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var page *Page
		var err error

		db, err := dburl.Open(*FlagURL)
		if err != nil {
			log.Fatal(err)
		}

		if pageID := chi.URLParam(r, "pageID"); pageID != "" {

			i, err := strconv.Atoi(pageID)
			if err != nil {
				log.Fatal(err)
			}

			page, err = PageByID(db, i)
			if err != nil {
				log.Fatal(err)
			}
		} else {
			//rnd.JSON(w, http.StatusNoContent, err)
			err := jsonapi.MarshalPayload(w, http.StatusNoContent)
			if err != nil {
				log.Fatal(err)
			}
			return
		}

		ctx := context.WithValue(r.Context(), "page", page)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func GetPageHandler(w http.ResponseWriter, r *http.Request) {
	// Assume if we've reach this far, we can access the article
	// context because this handler is a child of the PageCtx
	// middleware. The worst case, the recoverer middleware will save us.
	page := r.Context().Value("page").(*Page)

	//rnd.JSON(w, http.StatusOK, page)
	err := jsonapi.MarshalPayload(w, page)
	if err != nil {
		log.Fatal(err)
	}
}

// UpdatePage updates an existing Page in our persistent store.
func UpdatePage(w http.ResponseWriter, r *http.Request) {

	page := r.Context().Value("page").(*Page)

	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	err = json.NewDecoder(r.Body).Decode(&page)
	if err != nil {
		log.Fatal(err)
	}

	//TODO if json structure is contains different field it return an empty body... look for an approprate catch error for the public

	defer r.Body.Close()

	if err != nil {
		log.Fatal(err)
	}
	err = page.Update(db)
	if err != nil {
		fmt.Println(err)
		err = rnd.JSON(w, http.StatusNoContent, err)
		if err != nil {
			log.Fatal(err)
		}
	}

	err = rnd.JSON(w, http.StatusCreated, page)
	if err != nil {
		log.Fatal(err)
	}

	//fmt.Println(r.Body)

}

func PatchPage(w http.ResponseWriter, r *http.Request) {

	page := r.Context().Value("page").(*Page)

	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Fatal(err)
	}

	err = json.NewDecoder(r.Body).Decode(&page)
	if err != nil {
		fmt.Println(err)
	}

	err = page.Upsert(tx)
	if err != nil {
		fmt.Println(err)
		err = rnd.JSON(w, http.StatusNoContent, err)
		if err != nil {
			fmt.Println(err)
		}
	}

	err = rnd.JSON(w, http.StatusCreated, "successfully Update")
	if err != nil {
		fmt.Println(err)
	}
}

// DeleteArticle removes an existing Article from our persistent store.
func DeletePage(w http.ResponseWriter, r *http.Request) {

	page := r.Context().Value("page").(*Page)

	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	json.NewDecoder(r.Body).Decode(&page)

	err = page.Delete(db)
	if err != nil {
		fmt.Println(err)
		rnd.JSON(w, http.StatusNoContent, err)
	}

	rnd.JSON(w, http.StatusCreated, "OK")
}

func PageRt() chi.Router {
	r := chi.NewRouter()
	r.Route("/pageID}", func(r chi.Router) {
		r.Use(PageCtx)             // Load the *Article on the request context
		r.Get("/", GetPageHandler) // GET /articles/123
		r.Put("/", UpdatePage)     // PUT /articles/123
		r.Patch("/", UpdatePage)
		r.Delete("/", DeletePage) // DELETE /articles/123
	})

	// GET /articles/whats-up
	r.With(PageCtx).Get("/pageSlug:[a-z-]+}", GetPageHandler)

	return r
}

// Prepare for Elm Rest Sheet interface

/*************************************

module Main exposing (..)

import Browser
import Http
import RemoteData exposing (..)
import Json.Decode as Decode exposing (string, int, Decoder)
import Json.Decode.Pipeline exposing (required, optional)
import Json.Encode as Encode
import Html exposing (Html, text, h3, div, ul, li, b, button, a, br, input, hr, span, p)
import Html.Events exposing (onClick, onInput, onSubmit)
import Html exposing (Attribute)
import Html.Attributes exposing (href, type_, value, target, class)
import Url.Parser as Parser exposing ((</>), Parser, string, int)
import Url
import Url.Parser as UP
import Browser.Navigation as Nav



type alias Page =
      {
      , id: Int
      , title: Sql.NullString
      , slug: Sql.NullString
      , body: Sql.NullString
      , intro: Sql.NullString
      , created_date: Pq.NullTime
      , modified_date: Pq.NullTime }





type alias Frame =
    { title : String
    , content : List (Html Msg)
    }


type Route
    = ListPage
    | AddPage
    | ReadPage  ItemId
    | EditPage  ItemId
    | PageDelete ItemId
    | NotFound


type alias Model =
    { key : Nav.Key
    , url : Url.Url
    , route : Route
    , pages : WebData (List Page)
    , onepage : WebData Page
    , newpage : Page
    }




type alias ItemId =
    Int


tempItemId =
    -1

emptyPage : Page
emptyPage =
    Page "" "" "" "" tempItemId




findPageById : ItemId -> WebData (List Page) -> Maybe Page
findPageById pageId items =
    case RemoteData.toMaybe items of
        Just pages ->
            pages
                |> List.filter (\page -> page.id == pageId)
                |> List.head

        Nothing ->
            Nothing


--findCurrPageById : ItemId -> WebData Page -> Maybe Page
--findCurrPageById fieldId items =
--    case RemoteData.toMaybe items of
--        Just pages ->
--            pages
--                |> List.filter (\page -> page.id == fieldId)
--                |> List.head
--
--        Nothing ->
--            Nothing



decodePage : Decoder Page
decodePage =
    Decode.succeed Page
          |> required "id" (Decode.int)
          |> required "title" (Decode.sql.NullString)
          |> required "slug" (Decode.sql.NullString)
          |> required "body" (Decode.sql.NullString)
          |> required "intro" (Decode.sql.NullString)
          |> required "created_date" (Decode.pq.NullTime)
          |> required "modified_date" (Decode.pq.NullTime)




decodePages : Decoder (List Page)
decodePages =
    Decode.list (
        Decode.succeed Page
          |> required "id" (Decode.int)
          |> required "title" (Decode.sql.NullString)
          |> required "slug" (Decode.sql.NullString)
          |> required "body" (Decode.sql.NullString)
          |> required "intro" (Decode.sql.NullString)
          |> required "created_date" (Decode.pq.NullTime)
          |> required "modified_date" (Decode.pq.NullTime)
    )


encodePage : Page -> Encode.Value
encodePage page =
    Encode.object
        [
          , ("id",  Encode.int <| page.id)
          , ("title",  Encode.sql.NullString <| page.title)
          , ("slug",  Encode.sql.NullString <| page.slug)
          , ("body",  Encode.sql.NullString <| page.body)
          , ("intro",  Encode.sql.NullString <| page.intro)
          , ("created_date",  Encode.pq.NullTime <| page.created_date)
          , ("modified_date",  Encode.pq.NullTime <| page.modified_date)

        ]

newPageEncoder : Page -> Encode.Value
newPageEncoder page =
    Encode.object
        [
          , ("id", Encode.int <| page.id)
          , ("title", Encode.sql.NullString <| page.title)
          , ("slug", Encode.sql.NullString <| page.slug)
          , ("body", Encode.sql.NullString <| page.body)
          , ("intro", Encode.sql.NullString <| page.intro)
          , ("created_date", Encode.pq.NullTime <| page.created_date)
          , ("modified_date", Encode.pq.NullTime <| page.modified_date)
        ]


links : String
links =
    "http://localhost:9000"

fetchPagesCommand : Cmd Msg
fetchPagesCommand =
    Http.get
        { url = links ++ "/pages"
        , expect = Http.expectJson (RemoteData.fromResult >> PagesReceived) decodePages
        }


fetchPageCommand : String -> Cmd Msg
fetchPageCommand pageid =
    Http.get
        { url = links ++ "/page" ++ pageid
        , expect = Http.expectJson (RemoteData.fromResult >> PageReceived) decodePage
        }





updatePageHttp : Page -> Cmd Msg
updatePageHttp page =
  Http.request
    { method = "PUT"
    , headers = []
    , url = links ++ "/page/" ++ (String.fromInt page.id)
    , body = Http.jsonBody (encodePage page)
    , expect = Http.expectJson PageUpdated decodePage
    , timeout = Nothing
    , tracker = Nothing
    }


deletePageHttp : Page -> Cmd Msg
deletePageHttp page =
  Http.request
    { method = "DELETE"
    , headers = []
    , url = links ++ "/page/" ++ (String.fromInt page.id)
    , body = Http.jsonBody (encodePage page)
    , expect = Http.expectJson PageUpdated decodePage
    , timeout = Nothing
    , tracker = Nothing
    }


createPageHttp : Page -> Cmd Msg
createPageHttp page =
  Http.request
    { method = "POST"
    , headers = []
    , url = links ++ "/pages"
    , body = Http.jsonBody (newPageEncoder page)
    , expect = Http.expectJson PageCreated decodePages
    , timeout = Nothing
    , tracker = Nothing
    }



addNewPage : Page -> WebData (List Page) -> WebData (List Page)
addNewPage newPage pages =
    let
        appendPage : List Page -> List Page
        appendPage listOfPages =
            List.append listOfPages [ newPage ]
    in
        RemoteData.map appendPage pages




-- Link Routes to equivalent urls

routeMatch : UP.Parser (Route -> a) a
routeMatch =
    UP.oneOf
        [ UP.map ListPage UP.top
        , UP.map AddPage (UP.s "pages")
        , UP.map ReadPage (UP.s "page" </> Parser.int) -- page id
        , UP.map EditPage (UP.s "edit" </> Parser.int) -- Page id
        , UP.map PageDelete (UP.s "delete" </> Parser.int) -- Page id
        ]


urlToRoute : Url.Url -> Route
urlToRoute url=
    Maybe.withDefault NotFound (UP.parse routeMatch url)






updateNewpage : String  -> (String -> Page -> Page) -> Model -> ( Model, Cmd Msg )
updateNewpage newValue updateFunction model =
    let
        updatedNewPage =
            updateFunction newValue model.newpage
    in
        ( { model | newpage = updatedNewPage }, Cmd.none )
setID : String -> ID -> ID
setID newID field =
    { field | id = newID }
setTitle : String -> Title -> Title
setTitle newTitle field =
    { field | title = newTitle }
setSlug : String -> Slug -> Slug
setSlug newSlug field =
    { field | slug = newSlug }
setBody : String -> Body -> Body
setBody newBody field =
    { field | body = newBody }
setIntro : String -> Intro -> Intro
setIntro newIntro field =
    { field | intro = newIntro }
setCreatedDate : String -> CreatedDate -> CreatedDate
setCreatedDate newCreatedDate field =
    { field | created_date = newCreatedDate }
setModifiedDate : String -> ModifiedDate -> ModifiedDate
setModifiedDate newModifiedDate field =
    { field | modified_date = newModifiedDate }








updateField : ItemId -> String -> (String -> Page -> Page) -> Model -> ( Model, Cmd Msg )
updateField fieldId newValue updateFunction model =
    let
        updatePage field =
            if field.id == fieldId then
                updateFunction newValue field
            else
                field

        updatePages fields =
            List.map updatePage fields

        updatedPages =
            RemoteData.map updatePages model.pages
    in
        ( { model | pages = updatedPages }, Cmd.none )






type Msg
    = UrlChanged Url.Url
    | UrlRequested Browser.UrlRequest
    | FetchPages
    | FetchPage ItemId
    | PagesReceived (WebData (List Page))
    | PageReceived (WebData Page)
    | UpdatepageID ItemId String
    | UpdatepageTitle ItemId String
    | UpdatepageSlug ItemId String
    | UpdatepageBody ItemId String
    | UpdatepageIntro ItemId String
    | UpdatepageCreatedDate ItemId String
    | UpdatepageModifiedDate ItemId String
    | SubmitUpdatedPage ItemId
    | PageUpdated (Result Http.Error Page)
    | DeletePage ItemId
    | PageDeleted (Result Http.Error String)
    | NewpageID String
    | NewpageTitle String
    | NewpageSlug String
    | NewpageBody String
    | NewpageIntro String
    | NewpageCreatedDate String
    | NewpageModifiedDate String
    | SubmitNewPage
    | PageCreated (Result Http.Error (List Page))
    | Goto Route

update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
       case Debug.log "msg" msg of
           UrlRequested urlRequest ->
               case urlRequest of
                   Browser.Internal url ->
                       (model, Nav.pushUrl model.key (Url.toString url) )
                   Browser.External href ->
                       (model, Nav.load href)
           UrlChanged url ->
                       ( { model
                           | url = url
                           , route = urlToRoute url
                         }
                       , Cmd.none
                       )
           FetchPages ->
                       ( { model | pages = RemoteData.Loading }, fetchPagesCommand )
           FetchPage pathid ->
                       ( { model | onepage = RemoteData.Loading }, fetchPageCommand (String.fromInt pathid))

           PagesReceived response ->
               ( { model | pages = response }, Cmd.none)

           PageReceived response ->
               ( { model | onepage = response }, Cmd.none)

           UpdatepageID fieldId newID ->
               updateField fieldId newID setID model

           UpdatepageTitle fieldId newTitle ->
               updateField fieldId newTitle setTitle model

           UpdatepageSlug fieldId newSlug ->
               updateField fieldId newSlug setSlug model

           UpdatepageBody fieldId newBody ->
               updateField fieldId newBody setBody model

           UpdatepageIntro fieldId newIntro ->
               updateField fieldId newIntro setIntro model

           UpdatepageCreatedDate fieldId newCreatedDate ->
               updateField fieldId newCreatedDate setCreatedDate model

           UpdatepageModifiedDate fieldId newModifiedDate ->
               updateField fieldId newModifiedDate setModifiedDate model




           SubmitUpdatedPage pageId ->
                       case findPageById pageId model.pages of
                           Just page ->
                               ( model, updatePageHttp page )

                           Nothing ->
                               ( model, Cmd.none )

           PageUpdated _ ->
                       ( model, fetchPagesCommand )

           DeletePage pageId ->
                       case findPageById pageId model.pages of
                           Just page ->
                               ( model, deletePageHttp page )

                           Nothing ->
                               ( model, Cmd.none )

           PageDeleted _ ->
                       ( model, deletePageHttp model.newpage)


--           PageDeleted (Ok pages) ->
--                       ( { model |  pages = RemoteData.Loading , newpage = emptyPage }
--                      , Nav.replaceUrl model.key "/"
--                      )
--
--           PageDeleted (Err _) ->
--              ( model, Cmd.none )



           NewpageID newID ->
                       updateNewpage newID setID model



           NewpageTitle newTitle ->
                       updateNewpage newTitle setTitle model



           NewpageSlug newSlug ->
                       updateNewpage newSlug setSlug model



           NewpageBody newBody ->
                       updateNewpage newBody setBody model



           NewpageIntro newIntro ->
                       updateNewpage newIntro setIntro model



           NewpageCreatedDate newCreatedDate ->
                       updateNewpage newCreatedDate setCreatedDate model



           NewpageModifiedDate newModifiedDate ->
                       updateNewpage newModifiedDate setModifiedDate model



           SubmitNewPage ->
                       ( model, createPageHttp model.newpage )
           PageCreated (Ok pages) ->
                        ( { model |  pages = RemoteData.Success pages , newpage = emptyPage }
                       , Nav.replaceUrl model.key "/"
                       )

           PageCreated (Err _) ->
               ( model, Cmd.none )

           Goto _ ->
               ( model, Cmd.none )






subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none



viewPageStatus : Model -> Html Msg
viewPageStatus model =
    case model.pages of
        RemoteData.NotAsked -> text "Not Asked"
        RemoteData.Loading -> h3 [] [text "loading ..."]
        RemoteData.Success pages -> viewPages model.route pages
        RemoteData.Failure httpError -> viewError (createErrorMessage httpError)



viewOnePageStatus : Model -> Html Msg
viewOnePageStatus model =
    case model.onepage of
        RemoteData.NotAsked -> text "Not Asked"
        RemoteData.Loading -> h3 [] [text "loading ..."]
        RemoteData.Success onepage -> viewOnePage onepage
        RemoteData.Failure httpError -> viewError (createErrorMessage httpError)


viewError : String -> Html Msg
viewError errorMessage =
    let
        errorHeading =
            "Couldn't fetch Page data at this time."
    in
        div []
            [ h3 [] [ text errorHeading ]
            , text ("Error: " ++ errorMessage)
            ]


viewOnePage : Page -> Html Msg
viewOnePage page =
    span [ class "welcome-message" ]
        [ text page.title
        , p [] [ text page.body ]
        , p [] [ text page.tag ]
        , p [] [ text page.slug ]

        ]



viewPages : Route -> List Page -> Html Msg
viewPages model pages =
    ul [] ([(viewLinkOrText AddPage  model "New Page" "/pages")]++(List.map (onePage model) pages) )




onePage : Route -> Page -> Html Msg
onePage route page =
       li [] [ (viewLinkOrText (ReadPage page.id)  route page.title ("/page/"++(String.fromInt page.id)))
       , (viewLinkOrText (EditPage page.id)  route "  Edit" ("edit/"++(String.fromInt page.id)))
       ,  button [ onClick  (DeletePage page.id) ] [ text "Delete" ] ]



createErrorMessage : Http.Error -> String
createErrorMessage httpError =
    case httpError of
        Http.BadUrl message ->
            message

        Http.Timeout ->
            "Server is taking too long to respond. Please try again later."

        Http.NetworkError ->
            "It appears you don't have an Internet connection right now."

        Http.BadStatus statusCode ->
            String.fromInt statusCode
        Http.BadBody response ->
            response






init : () -> Url.Url -> Nav.Key -> ( Model, Cmd Msg )
init _ url key =
    ( { key = key, url = url, route = urlToRoute url , pages = RemoteData.Loading, onepage = RemoteData.NotAsked, newpage = emptyPage }, fetchPagesCommand )




view : Model -> Browser.Document Msg
view  model =
    let
        pg =
            case model.route of
                ListPage ->
                    pageHome model
                AddPage ->
                    pageAdd
                ReadPage pageId -> -- fieldId
                    case findPageById pageId model.pages of
                                    Just page ->
                                        pageRead page
                                    Nothing ->
                                        pageNotFound
                EditPage pageId->  -- PageID
                    case findPageById pageId model.pages of
                                    Just page ->
                                        pageEdit page
                                    Nothing ->
                                        pageNotFound
                NotFound->
                    pageNotFound
                PageDelete pageId ->
                    pageHome model
     in
    { title = pg.title,
    body =
         viewHeader
         ++ pg.content
         ++ viewFooter model.route
     }





viewHeader : List (Html msg)
viewHeader =
    [ a [ href "https://www.markuslaire.com/github/elm-examples/index.html" ] [ text "Index" ]
    ]


viewFooter : Route -> List (Html msg)
viewFooter currentRoute =
    [ hr [] []
    , viewLinkOrText currentRoute ListPage "Home" "/"
    , text " ☆ "
    , viewLinkOrText currentRoute AddPage "New Page" "/pages"
    , text " ☆ "
--    , viewLinkOrText currentRoute ReadPage "Help" "/help"
--    , text " ☆ "
--    , viewLinkOrText currentRoute EditPage "Help" "/help"
    ]





viewExternalLink : String -> String -> Html msg
viewExternalLink linkText linkHref =
    a [ href linkHref, target "_blank" ] [ text linkText ]


viewLinkOrText : Route -> Route -> String -> String -> Html msg
viewLinkOrText currentRoute linkRoute linkText linkHref =
    if currentRoute == linkRoute then
        b [] [ text linkText ]

    else
        a [ href linkHref ] [ text linkText ]



newPageForm : Html Msg
newPageForm =
    Html.form [ onSubmit SubmitNewPage ]
        [ div []
            , div []
            [ text "ID"
            , br [] []

            , input
                [ type_ "text"
                , onInput NewpageID
                ]
                []

            ]

        , br [] []
            , div []
            [ text "Title"
            , br [] []

            , input
                [ type_ "text"
                , onInput NewpageTitle
                ]
                []

            ]

        , br [] []
            , div []
            [ text "Slug"
            , br [] []

            , input
                [ type_ "text"
                , onInput NewpageSlug
                ]
                []

            ]

        , br [] []
            , div []
            [ text "Body"
            , br [] []

            , input
                [ type_ "text"
                , onInput NewpageBody
                ]
                []

            ]

        , br [] []
            , div []
            [ text "Intro"
            , br [] []

            , input
                [ type_ "text"
                , onInput NewpageIntro
                ]
                []

            ]

        , br [] []
            , div []
            [ text "CreatedDate"
            , br [] []

            , input
                [ type_ "text"
                , onInput NewpageCreatedDate
                ]
                []

            ]

        , br [] []
            , div []
            [ text "ModifiedDate"
            , br [] []

            , input
                [ type_ "text"
                , onInput NewpageModifiedDate
                ]
                []

            ]

        , br [] []
        , div []
            [ button [  ]
                [ text "Submit" ]
            ]
        ]

-- infert the appropriate model fields.
editPageForm : Page -> Html Msg
editPageForm page =
    Html.form [ onSubmit (SubmitUpdatedPage page.id) ]
        [ div []
        , div []
            [ text "id"
            , br [] []
            , input
                [ type_ "text"
                , value page.id
                , onInput (UpdatepageID page.id)
                ]
                []
            ]
        , br [] []
        , div []
            [ text "title"
            , br [] []
            , input
                [ type_ "text"
                , value page.title
                , onInput (UpdatepageTitle page.id)
                ]
                []
            ]
        , br [] []
        , div []
            [ text "slug"
            , br [] []
            , input
                [ type_ "text"
                , value page.slug
                , onInput (UpdatepageSlug page.id)
                ]
                []
            ]
        , br [] []
        , div []
            [ text "body"
            , br [] []
            , input
                [ type_ "text"
                , value page.body
                , onInput (UpdatepageBody page.id)
                ]
                []
            ]
        , br [] []
        , div []
            [ text "intro"
            , br [] []
            , input
                [ type_ "text"
                , value page.intro
                , onInput (UpdatepageIntro page.id)
                ]
                []
            ]
        , br [] []
        , div []
            [ text "created_date"
            , br [] []
            , input
                [ type_ "text"
                , value page.created_date
                , onInput (UpdatepageCreatedDate page.id)
                ]
                []
            ]
        , br [] []
        , div []
            [ text "modified_date"
            , br [] []
            , input
                [ type_ "text"
                , value page.modified_date
                , onInput (UpdatepageModifiedDate page.id)
                ]
                []
            ]
        , br [] []
        , div []
            [ button []
                [ text "Submit" ]
            ]
        ]


pageHome : Model -> Frame
pageHome model =
    { title = "Home"
    , content =
        [ text "Welcome to this basic Elm SPA (Single Page Application) example."
        , br [] []
        , viewPageStatus model
        , text "Here's an invalid link to test the error page: "
        , a [ href "/abc/xyz" ] [ text "invalid link" ]
        ]
    }


pageAdd : Frame
pageAdd =
    { title = "New Page"
    , content =
        [ text "Add Page"
        , newPageForm
        ]
    }


pageEdit : Page -> Frame
pageEdit page =
    { title = "Edit Page"
    , content =
        [ text "Edit Page."
        , editPageForm page
        ]
    }


pageRead : Page -> Frame
pageRead page =
    { title = "Help"
    , content =
        [ text "Useful links:"
        , viewOnePage page
        ]
    }


pageNotFound : Frame
pageNotFound  =
    { title = "Page not found"
    , content =
        [ text "ERROR: Page "
        , text " not found."
        ]
    }


main =
    Browser.application
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        , onUrlChange = UrlChanged
        , onUrlRequest = UrlRequested
        }

*************************************/
// PageByID retrieves a row from 'sweb.pages' as a Page.
//
// Generated from index 'pages_pkey'.
func PageByID(db XODB, id int) (*Page, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, title, slug, body, intro, created_date, modified_date ` +
		`FROM sweb.pages ` +
		`WHERE id = $1`

	// run query
	XOLog(sqlstr, id)
	p := Page{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&p.ID, &p.Title, &p.Slug, &p.Body, &p.Intro, &p.CreatedDate, &p.ModifiedDate)
	if err != nil {
		return nil, err
	}

	return &p, nil
}
