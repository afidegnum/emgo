// Package models contains the types for schema 'public'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"log"
	"net/http"
	"strconv"

	"github.com/go-chi/chi"
	"github.com/google/jsonapi"
	"github.com/thedevsaddam/renderer"
	"github.com/xo/dburl"
)

var rnd = renderer.New()

var flagVerbose = flag.Bool("v", false, "verbose")

var FlagURL = flag.String("url", "postgres://postgres:@127.0.0.1/sweb", "url")

// Page represents a row from 'public.pages'.
type Page struct {
	Tag   string `jsonapi:"attr,tag" json:"tag"`     // tag
	Body  string `jsonapi:"attr,body" json:"body"`   // body
	Slug  string `jsonapi:"attr,slug" json:"slug"`   // slug
	Title string `jsonapi:"attr,title" json:"title"` // title
	ID    int    `jsonapi:"primary,pages" json:"id"` // id

	// xo fields
	_exists, _deleted bool
}

func panicError(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func (page Page) JSONAPILinks() *jsonapi.Links {
	return &jsonapi.Links{
		"self": fmt.Sprintf("https://%d", page.ID),
	}
}

// Exists determines if the Page exists in the database.
func (p *Page) Exists() bool {
	return p._exists
}

// Deleted provides information if the Page has been deleted from the database.
func (p *Page) Deleted() bool {
	return p._deleted
}

// Insert inserts the Page to the database and return its results.

//Error : Receiver names are different
func (p *Page) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if p._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO public.pages (` +
		`tag, body, slug, title` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING id`

	// run query
	XOLog(sqlstr, p.Tag, p.Body, p.Slug, p.Title)
	err = db.QueryRow(sqlstr, p.Tag, p.Body, p.Slug, p.Title).Scan(&p.ID)
	if err != nil {
		return err
	}

	// set existence
	p._exists = true

	return nil
}

func (p *Page) PInsert(db XODB) (*Page, error) {
	var err error

	// if already exist, bail
	if p._exists {
		return p, errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO public.pages (` +
		`tag, body, slug, title` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING id`

	// run query
	XOLog(sqlstr, p.Tag, p.Body, p.Slug, p.Title)
	err = db.QueryRow(sqlstr, p.Tag, p.Body, p.Slug, p.Title).Scan(&p.ID)
	if err != nil {
		return p, err
	}

	// set existence
	p._exists = true

	return p, nil
}

// Update updates the Page in the database and return last inserted records.
func (p *Page) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !p._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if p._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE public.pages SET (` +
		`tag, body, slug, title` +
		`) = ( ` +
		`$1, $2, $3, $4` +
		`) WHERE id = $5`

	// run query
	XOLog(sqlstr, p.Tag, p.Body, p.Slug, p.Title, p.ID)
	_, err = db.Exec(sqlstr, p.Tag, p.Body, p.Slug, p.Title, p.ID)
	return err
}

func (p *Page) PSave(db XODB) (*Page, error) {
	if p.Exists() {
		return p, p.Update(db)
	}

	return p.PInsert(db)
}

// Save saves the Page to the database.
func (p *Page) Save(db XODB) (*Page, error) {
	if p.Exists() {
		return p, p.Update(db)
	}

	return p, p.Insert(db)
}

// Upsert performs an upsert for Page.
//
// NOTE: PostgreSQL 9.5+ only
func (p *Page) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if p._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO public.pages (` +
		`tag, body, slug, title, id` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) ON CONFLICT (id) DO UPDATE SET (` +
		`tag, body, slug, title, id` +
		`) = (` +
		`EXCLUDED.tag, EXCLUDED.body, EXCLUDED.slug, EXCLUDED.title, EXCLUDED.id` +
		`)`

	// run query
	XOLog(sqlstr, p.Tag, p.Body, p.Slug, p.Title, p.ID)
	_, err = db.Exec(sqlstr, p.Tag, p.Body, p.Slug, p.Title, p.ID)
	if err != nil {
		return err
	}

	// set existence
	p._exists = true

	return nil
}

// Delete deletes the Page from the database.
func (p *Page) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !p._exists {
		return nil
	}

	// if deleted, bail
	if p._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM public.pages WHERE id = $1`

	// run query
	XOLog(sqlstr, p.ID)
	_, err = db.Exec(sqlstr, p.ID)
	if err != nil {
		return err
	}

	// set deleted
	p._deleted = true

	return nil
}

// PageByID retrieves a row from 'public.pages' as a Page.
//
// Generated from index 'pages_ix1'.
func PageByID(db XODB, id int) (*Page, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`tag, body, slug, title, id ` +
		`FROM public.pages ` +
		`WHERE id = $1`

	// run query
	XOLog(sqlstr, id)
	p := Page{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&p.Tag, &p.Body, &p.Slug, &p.Title, &p.ID)
	if err != nil {
		return nil, err
	}

	return &p, nil
}

// PageBySlug retrieves a row from 'public.pages' as a Page.
//
// Generated from index 'pages_ix2'.
func PageBySlug(db XODB, slug string) (*Page, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`tag, body, slug, title, id ` +
		`FROM public.pages ` +
		`WHERE slug = $1`

	// run query
	XOLog(sqlstr, slug)
	p := Page{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, slug).Scan(&p.Tag, &p.Body, &p.Slug, &p.Title, &p.ID)
	if err != nil {
		return nil, err
	}

	return &p, nil
}

// PageByID retrieves a row from 'public.pages' as a Page.
//
// Generated from index 'pages_pkey'.
func PageByIDs(db XODB, id int) (*Page, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`tag, body, slug, title, id ` +
		`FROM public.pages ` +
		`WHERE id = $1`

	// run query
	XOLog(sqlstr, id)
	p := Page{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&p.Tag, &p.Body, &p.Slug, &p.Title, &p.ID)
	if err != nil {
		return nil, err
	}

	return &p, nil
}

// FetchAllPage returns all from 'public.pages',

func FetchAllPage(db XODB) ([]*Page, error) {
	const sqlstr = `SELECT ` +
		`tag, body, slug, title, id, FROM public.pages`

	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	var res []*Page
	for q.Next() {
		p := Page{}

		// scan
		err = q.Scan(&p.Tag, &p.Body, &p.Slug, &p.Title, &p.ID)
		if err != nil {
			return nil, err
		}

		res = append(res, &p)

	}

	return res, nil
}

func PageHandler(w http.ResponseWriter, r *http.Request) {

	//DB OPERATIONS START

	flag.Parse()
	if *flagVerbose {
		XOLog = func(s string, p ...interface{}) {
			fmt.Printf("-------------------------------------\nQUERY: %s\n  VAL: %v\n", s, p)
		}
	}

	// open database
	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	res, err := FetchAllPage(db)

	if err != nil {
		log.Fatal(err)
	}
	w.Header().Set("Content-Type", jsonapi.MediaType)

	if err := jsonapi.MarshalPayload(w, res); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}

}

func NewPage(w http.ResponseWriter, r *http.Request) {

	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	defer db.Close()

	var page Page

	if err := jsonapi.UnmarshalPayload(r.Body, &page); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	//page := new(Page)
	// 1. Save the page in the database, bail on error

	p, err := page.PSave(db)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// 2. Marshal the page into an intermediate buffer, bail on error

	var buf bytes.Buffer
	if err := jsonapi.MarshalPayload(&buf, p); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// 3. Write the entire response; failures to write the intermediate buffer
	// cannot be communicated over HTTP
	w.Header().Set("Content-Type", jsonapi.MediaType)
	w.WriteHeader(http.StatusCreated)
	if _, err := buf.WriteTo(w); err != nil {
		log.Printf("failed to write response: %v", err)
		return
	}

}

func GetPage(w http.ResponseWriter, r *http.Request) {

	//DB OPERATIONS START

	flag.Parse()
	if *flagVerbose {
		XOLog = func(s string, p ...interface{}) {
			fmt.Printf("-------------------------------------\nQUERY: %s\n  VAL: %v\n", s, p)
		}
	}

	// open database
	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	res, err := FetchAllPage(db)

	if err != nil {
		log.Fatal(err)
	}

	rnd.JSON(w, http.StatusOK, res)

}

//ROUTE HANDLERS

func PageCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var page *Page
		var err error

		db, err := dburl.Open(*FlagURL)
		if err != nil {
			log.Fatal(err)
		}

		if pageID := chi.URLParam(r, "pageID"); pageID != "" {

			i, err := strconv.Atoi(pageID)
			if err != nil {
				log.Fatal(err)
			}

			page, err = PageByID(db, i)
			if err != nil {
				log.Fatal(err)
			}
		} else {
			//rnd.JSON(w, http.StatusNoContent, err)
			err := jsonapi.MarshalPayload(w, http.StatusNoContent)
			if err != nil {
				log.Fatal(err)
			}
			return
		}

		//if err != nil {
		//	rnd.JSON(w, http.StatusNoContent, err)
		//	return
		//}

		ctx := context.WithValue(r.Context(), "page", page)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func GetPageHandler(w http.ResponseWriter, r *http.Request) {
	// Assume if we've reach this far, we can access the article
	// context because this handler is a child of the ArticleCtx
	// middleware. The worst case, the recoverer middleware will save us.
	page := r.Context().Value("page").(*Page)

	//rnd.JSON(w, http.StatusOK, page)
	err := jsonapi.MarshalPayload(w, page)
	if err != nil {
		log.Fatal(err)
	}
}

// UpdateArticle updates an existing Article in our persistent store.
//func UpdatePage(w http.ResponseWriter, r *http.Request) {
//
//	page := r.Context().Value("page").(*Page)
//
//	db, err := dburl.Open(*FlagURL)
//	if err != nil {
//		log.Fatal(err)
//	}
//
//	//tx, err := db.Begin()
//	//if err != nil {
//	//	log.Fatal(err)
//	//}
//
//	//err = json.NewDecoder(r.Body).Decode(&page)
//	if err := jsonapi.UnmarshalPayload(r.Body, &page); err != nil {
//		http.Error(w, err.Error(), http.StatusInternalServerError)
//		//log.Fatal(&page)
//		//log.Fatal(&page)
//		return
//	}
//
//
//	defer r.Body.Close()
//
//	if err != nil {
//		log.Fatal(err)
//	}
//	err = page.Update(db)
//	if err != nil {
//		http.Error(w, err.Error(), http.StatusNoContent)
//		return
//		//fmt.Println(err)
//		//err = rnd.JSON(w, http.StatusNoContent, err)
//		//if err != nil {
//		//	log.Fatal(err)
//		//}
//	}
//
//	//err = rnd.JSON(w, http.StatusCreated, p)
//	//if err != nil {
//	//	log.Fatal(err)
//	//}
//	//log.Print(page)
//
//	var buf bytes.Buffer
//	if err := jsonapi.MarshalPayload(&buf, page); err != nil {
//		http.Error(w, err.Error(), http.StatusInternalServerError)
//		return
//	}
//
//	// 3. Write the entire response; failures to write the intermediate buffer
//	// cannot be communicated over HTTP
//	w.Header().Set("Content-Type", jsonapi.MediaType)
//	w.WriteHeader(http.StatusCreated)
//	if _, err := buf.WriteTo(w); err != nil {
//		log.Printf("failed to write response: %v", err)
//		return
//	}
//}

// UpdateArticle updates an existing Article in our persistent store.
func UpdatePage(w http.ResponseWriter, r *http.Request) {

	page := r.Context().Value("page").(*Page)

	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	err = json.NewDecoder(r.Body).Decode(&page)
	if err != nil {
		log.Fatal(err)
	}

	//TODO if json structure is contains different field it return an empty body... look for an approprate catch error for the public

	//respBody, err := ioutil.ReadAll(r.Body)
	//if len(respBody) == 0 {
	//	log.Print(respBody)
	//}

	defer r.Body.Close()

	if err != nil {
		log.Fatal(err)
	}
	err = page.Update(db)
	if err != nil {
		fmt.Println(err)
		err = rnd.JSON(w, http.StatusNoContent, err)
		if err != nil {
			log.Fatal(err)
		}
	}

	err = rnd.JSON(w, http.StatusCreated, page)
	if err != nil {
		log.Fatal(err)
	}

	//fmt.Println(r.Body)

}

func PatchPage(w http.ResponseWriter, r *http.Request) {

	page := r.Context().Value("page").(*Page)

	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	tx, err := db.Begin()
	if err != nil {
		log.Fatal(err)
	}

	err = json.NewDecoder(r.Body).Decode(&page)
	if err != nil {
		fmt.Println(err)
	}

	err = page.Upsert(tx)
	if err != nil {
		fmt.Println(err)
		err = rnd.JSON(w, http.StatusNoContent, err)
		if err != nil {
			fmt.Println(err)
		}
	}

	err = rnd.JSON(w, http.StatusCreated, "successfully Update")
	if err != nil {
		fmt.Println(err)
	}
}

// DeleteArticle removes an existing Article from our persistent store.
func DeletePage(w http.ResponseWriter, r *http.Request) {

	page := r.Context().Value("page").(*Page)

	db, err := dburl.Open(*FlagURL)
	if err != nil {
		log.Fatal(err)
	}

	json.NewDecoder(r.Body).Decode(&page)

	err = page.Delete(db)
	if err != nil {
		fmt.Println(err)
		rnd.JSON(w, http.StatusNoContent, err)
	}

	rnd.JSON(w, http.StatusCreated, "OK")
}

func PageRt() chi.Router {
	r := chi.NewRouter()
	r.Route("/{pageID}", func(r chi.Router) {
		r.Use(PageCtx)             // Load the *Article on the request context
		r.Get("/", GetPageHandler) // GET /articles/123
		r.Put("/", UpdatePage)     // PUT /articles/123
		r.Patch("/", UpdatePage)
		r.Delete("/", DeletePage) // DELETE /articles/123
	})

	// GET /articles/whats-up
	r.With(PageCtx).Get("/{pageSlug:[a-z-]+}", GetPageHandler)

	return r
}

/*
This is the elm version
This is where to bake the Model and Almost Views.
which will later be exported to ELM file,

*/
